

<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>JSDoc: services/data_service.js</title>

    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="./build/entry.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link href="https://fonts.googleapis.com/css?family=Muli:100,400,700|Oswald:300|Inconsolata,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
    <link type="text/css" rel="stylesheet" href="styles/app.min.css">
    <link type="text/css" rel="stylesheet" href="styles/iframe.css">
</head>

<body>
    <div id="stickyNavbarOverlay"></div>
    <div class="top-navbar">
        <div class="container">
            <nav class="navbar" role="navigation" aria-label="main navigation">
                <div class="navbar-brand">
                    
                     
                        <h1 class="navbar-item">State Management Server</h1>
                    
                    <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                    </a>
                </div>
                 
                <div class="navbar-menu">
                    <div class="navbar-end">
                    
                        <div class="navbar-item">
                            <a href="https://github.com/SoftwareBrothers/admin-bro" target="_blank">Github</a>
                        </div>
                    
                        <div class="navbar-item">
                            <a href="https://admin-bro-example-app.herokuapp.com/admin" target="_blank">Example Application</a>
                        </div>
                    
                    </div>
                </div>
                
            </nav>
        </div>
    </div>
    <div class="container">
        <div class="columns">
            <div class="column is-3" id="sidebarNav">
                <div class="sidebar">
                    <nav>
                        <h2><a href="index.html">Home</a></h2><div class="category"><h3><a href="global.html">Global</a></h3></div><div class="category"><h2>Models</h2><h3>Classes</h3><ul><li><a href="BlastModel.html">BlastModel</a></li><li><a href="ControlUnitModel.html">ControlUnitModel</a></li><li><a href="DataModel.html">DataModel</a></li><li><a href="UnitModel.html">UnitModel</a></li></ul></div><div class="category"><h2>Repositories</h2><h3>Classes</h3><ul><li><a href="BlastRepository.html">BlastRepository</a></li></ul></div><div class="category"><h2>Services</h2><h3>Classes</h3><ul><li><a href="BlastService.html">BlastService</a></li><li><a href="DataService.html">DataService</a></li><li><a href="QueueService.html">QueueService</a></li><li><a href="SecurityService.html">SecurityService</a></li><li><a href="SystemService.html">SystemService</a></li><li><a href="uiService.html">uiService</a></li></ul><h3>Events</h3><ul><li><a href="BlastModel.html#event:state">state</a></li><li><a href="DataService.html#event:EDDSIG">EDDSIG</a></li><li><a href="global.html#event:DataService">DataService</a></li></ul></div><div class="category"><h2>Utilities</h2><h3>Modules</h3><ul><li><a href="module-lib_mappers_data_mapper.html">lib/mappers/data_mapper</a></li></ul><h3>Classes</h3><ul><li><a href="module-lib_mappers_data_mapper-DataMapper.html">DataMapper</a></li></ul></div>
                    </nav>
                </div>
            </div>
            <div class="column is-9-desktop">
                <div class="content" id="main-content-wrapper">
                    <header class="page-title">
                        <p>Source</p>
                        <h1>services/data_service.js</h1>
                    </header>
                    
                    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* eslint-disable no-unused-vars */

const PacketTemplate = require("../constants/packetTemplates");
const DataModel = require("../models/dataModel");
const DataMapper = require("../mappers/data_mapper");
const clone = require("clone");

const { componentStates } = require("../constants/stateConstants");
const { dataModelEvents, dataServiceEvents } = require("../constants/eventConstants");

/**
 * @category Services
 * @class DataService
 * @requires PacketTemplate
 * @requires module:lib/models/dataModel
 * @requires module:DataMapper
 * @requires clone
 * @requires pdfUtils
 * @requires better-queue
 * @prop {DataModel} this.dataModel The Core State DataModel
 * @prop {object} this.__constants Constants
 * @prop {DataMapper} this.dataMapper The Diff mapper
 * @prop {array} this._eventRefs List of event refs required for removal on stop
 */
function DataService() {
	this.dataModel = null;
	this.__constants = new PacketTemplate();
	this.dataMapper = new DataMapper();
	this._eventRefs = [];
}

/**
 * &lt;ul>
 * &lt;li>Start the component when Happner starts.&lt;/li>
 * &lt;li>Creates a new DataModel and Emit Queue.&lt;/li>
 * &lt;li>Starts the listners for the Data Model&lt;/li>&lt;/ul>&lt;br>
 * @param {$happn} $happn Dependancy Injection of the Happner Framework
 * @returns {Promise}
 */
DataService.prototype.componentStart = function($happn) {
	const { stateService } = $happn.exchange;
	const { name } = $happn;

	return (async () => {
		try {
			stateService.updateState({ service: name, state: componentStates.INITIALIZED });
		} catch (error) {
			stateService.updateState({ service: name, state: componentStates.FAILED, error });
		}
	})();
};

/**
 * &lt;ul>
 * &lt;li>Stops the component when Happner stops.&lt;/li>
 * &lt;li>Stops the listners.&lt;/li>
 * &lt;li>Starts the listners for the Data Model&lt;/li>&lt;/ul>&lt;br>
 * @param {$happn} $happn Dependancy Injection of the Happner Framework
 * @returns {Promise} void
 */
DataService.prototype.componentStop = function($happn) {
	const { stateService, dataService } = $happn.exchange;
	const { name } = $happn;

	return (async () => {
		await dataService.unlisten();
		stateService.updateState({ service: name, state: componentStates.STOPPED });
	})();
};

/**
 * &lt;ul>
 * &lt;li>Called by {@link module:app~App#startRouter}.&lt;/li>
 * &lt;li>Starts the listners for the Data Model&lt;/li>&lt;/ul>&lt;br>
 * @param {$happn} $happn Dependancy Injection of the Happner Framework
 * @returns {Promise}
 */
DataService.prototype.initialise = function($happn) {
	const { dataService, stateService } = $happn.exchange;
	const { name } = $happn;

	return (async () => {
		try {
			await dataService.createDataModel();
			await dataService.createDataModelListeners();
		} catch (error) {
			stateService.updateState({ service: name, state: componentStates.FAILED, error });
		}
	})();
};

/**
 * &lt;ul>&lt;li>Create and populate the DataModel on startup of this Service.&lt;/li>
 * &lt;li>Gets the persisted units from the datastore&lt;/li>
 * @param {$happn} $happn Dependancy Injection of the Happner Framework
 * @returns {Promise}
 * @mermaid graph LR
 * 		A[New DataModel]-->B[createListeners]
 * 		B-.->C[getAllPersisted]
 * 		C-->D[validateUnits]
 * 		D-->|populate units|A
 */
DataService.prototype.createDataModel = function($happn) {
	const { nodeRepository, dataService } = $happn.exchange;
	const { log } = $happn;
	const { env } = $happn.config;

	return (async () => {
		try {
			this.dataModel = new DataModel();
			this.dataModel.setMode(env.systemMode);

			const units = await nodeRepository.get("*");

			const validatedUnits = await dataService.validatePersisted(units);

			if (validatedUnits) {
				for (const unit of validatedUnits) {
					await this.dataModel.upsertUnit(unit, true);
				}
			} else {
				log.warn("No Units found in Node Repository.... DataModel is empty");
			}
		} catch (error) {
			log.error(error);
			throw new Error(`Data Model creation error: ${error.message}`);
		}
	})();
};

/**
 * &lt;ul>&lt;li>Starts the listners for the Data Model.&lt;/li>
 * &lt;li>Broker the events from the DataModel to the rest of the system.&lt;/li>&lt;/ul>&lt;br>
 * @param {$happn} $happn Dependancy Injection of the Happner Framework
 * @returns {Promise} void
 * @listens DataModel#UNIT_COUNT - Brokers emits and hands to Happn Emit
 * @listens DataModel#UNIT_COMMS_LOST - Handles the timer for Comms lost on timed units
 * @listens DataModel#error Handles the error logging inside the data model to the Happn Logger
 */
DataService.prototype.createDataModelListeners = function($happn) {
	const { eventService } = $happn.exchange;
	const { log } = $happn;

	return (async () => {
		try {
			this.dataModel.on(dataModelEvents.UNIT_COUNT_UPDATED, val =>
				eventService.handleEvent({
					type: dataServiceEvents.UNIT_COUNT_CHANGED,
					serial: val.serial,
					createdAt: val.createdAt,
					typeId: val.typeId,
					counts: val.counts
				})
			);

			//send a unit update to the events service to notify changes
			this.dataModel.on(dataModelEvents.UNIT_COMMS_LOST, val => {
				//log.info(`Communication lost for unit - ${val.serial}`);
				// eventService.handleEvent({
				// 	type: dataServiceEvents.UNITS_UPDATED,
				// 	serial: val.serial,
				// 	createdAt: val.createdAt,
				// 	typeId: val.typeId,
				// 	payload: [{ serial: val.serial, diff: { communicationStatus: 0 } }]
				// });
			});
		} catch (err) {
			log.error(err);
		}
	})();
};

/**
 * &lt;ul>&lt;li>Removes the listners from the Data Model.&lt;/li>&lt;/ul>
 * @param {$happn} $happn Dependancy Injection of the Happner Framework
 * @returns {Promise}
 */
DataService.prototype.unlisten = function($happn) {
	const { log } = $happn;
	const allEvents = Object.values(dataModelEvents);

	return (async () => {
		try {
			if (!this.dataModel) throw new Error("No DataModel");
			allEvents.forEach(ev => this.dataModel.removeAllListeners(ev));
		} catch (err) {
			log.error("Error removing listeners..", err.message);
		}
	})();
};

/**
 * &lt;ul>&lt;li>Validate the persisted Units and return to the create method&lt;/li>&lt;/ul>
 * @param {$happn} $happn Dependancy Injection of the Happner Framework
 * @returns {(Promise&lt;units[]> | Promise&lt;null>)} result Array or null
 */
DataService.prototype.validatePersisted = function($happn, units) {
	const { log } = $happn;

	return (async () => {
		try {
			let resultArr = [];

			let controlUnit = await units.filter(u => u.typeId === 0);

			if (controlUnit &amp;&amp; controlUnit.length > 0) {
				if (controlUnit.length > 1) {
					const allCu = controlUnit.reduce((acc, cur) => acc.concat(`-${cur.path}  `), "");
					controlUnit = controlUnit.sort((a, b) => a.modifiedAt &lt; b.modifiedAt);
					log.warn(`Too Many control units found.... please remove one of ${allCu}`);
					log.warn(`Adding latest to Blast Model - unit ${controlUnit[0].path}`);
				}

				resultArr.push(controlUnit[0]);
				log.info(`Adding Control Unit ${controlUnit[0].serial}`);
			} else {
				log.warn("No Control Unit found...");
			}

			let boosters = units.filter(u => u.typeId === 3);
			if (boosters &amp;&amp; boosters.length > 0) {
				log.info(`Adding ${boosters.length} boosters to the Data Model`);
				for (let booster of boosters) {
					log.info(`Adding ${booster.serial} to the Data Model`);
					resultArr.push(booster);
				}
			} else {
				log.info("No Boosters found in the Data Store.");
			}

			let dets = units.filter(u => u.typeId === 4);
			if (dets &amp;&amp; dets.length > 0) {
				log.info(`Adding ${dets.length} detonators to the Data Model`);
				for (let det of dets) {
					resultArr.push(det);
				}
			} else {
				log.info("No Detonators found in the Data Store.");
			}

			if (resultArr.length > 0) {
				const remappedUnits = await this.dataMapper.mapToUnits(resultArr);
				return remappedUnits;
			}
			return null;
		} catch (err) {
			log.error("Error validating the persisted data ", err);
		}
	})();
};

/**
 * &lt;ul>&lt;li>Clears the DataModel by creating a new DataModel instance.&lt;/li>
 * &lt;li>Utiliity method for now&lt;/li>&lt;/ul>
 * @param {$happn} $happn Dependancy Injection of the Happner Framework
 * @returns {Promise}
 */
DataService.prototype.clearDataModel = function($happn) {
	return new Promise((resolve, reject) => {
		this.dataModel = new DataModel();
		resolve();
	});
};

/**
 * &lt;ul>&lt;li>Primary Pathway for the Node Array&lt;/li>
 * &lt;li>Handles upserting and flow&lt;/li>&lt;/ul>&lt;br>
 * @param {$happn} $happn Dependancy Injection of the Happner Framework
 * @param {object[]} nodeArr The incoming node array
 * @returns {Promise}
 * @mermaid graph LR
 				A[nodeArr]-.->|from queue|B[upsertNodeDataArr]
 				B-->|check conditions|C{PreProcess}
 				C-->|EDD_CLEARSIG|resetChildCount
 				resetChildCount-->|EDD_CLEARSIG|updateState
 				C-->|FILTERED|updateState
 				C-->|CLEAR|updateState
 				updateState-->postProcess
 */
DataService.prototype.upsertNodeDataArr = function($happn, nodeArr) {
	const { dataService, nodeRepository, eventService } = $happn.exchange;
	const { log } = $happn;

	return (async () => {
		try {
			if (!Array.isArray(nodeArr)) throw new Error("variable NodeArray is not an Array");

			const preProcess = await dataService.preProcess(nodeArr);

			let updateRes;

			switch (preProcess.type) {
			case "DEFAULT":
				updateRes = await dataService.updateState(nodeArr);
				break;

			case "EDD_CLEARSIG":
				await this.dataModel.resetChildCount(nodeArr[0]);
				nodeArr[0].data.childCount = 0;
				updateRes = await dataService.updateState([nodeArr[0]]);

				if (!nodeArr[0].data.path) nodeArr[0].setPath();

				await eventService.handleEvent({
					type: dataServiceEvents.EDD_SIGNAL_DETECTED,
					serial: nodeArr[0].data.serial,
					createdAt: nodeArr[0].data.createdAt,
					typeId: nodeArr[0].data.typeId
				});
				await nodeRepository.cutPath(nodeArr[0].data.path);

				break;

			case "FILTERED":
				updateRes = await dataService.updateState(preProcess.value);
				break;

			default:
				throw new Error("Process Type must be suppled");
			}

			if (updateRes &amp;&amp; updateRes.updates.length > 0) {
				await dataService.postProcess(nodeArr[0], updateRes.updates);
			}

			return true;
		} catch (err) {
			log.warn("DataService Upsert Error: ", err.message);
			throw new Error(err.message);
		}
	})();
};

/**
 * &lt;ul>&lt;li>Update the state of the checked Array&lt;/li>
 * &lt;li>.....&lt;/li>&lt;/ul>&lt;br>
 * @param {$happn} $happn Dependancy Injection of the Happner Framework
 * @param {object[]} nodeArr The incoming node array
 * @param {boolean} force force update flag
 * @returns {Promise}
 * @mermaid sequenceDiagram
 				updateState->>dataModel: upsertUnit
 				dataModel->>updateState: return action
 				Note left of updateState: INSERT, UPDATE or NONE
 				updateState->>__updateExistingNodes: update
 				updateState->>__insertNewNodes: insert
 */
DataService.prototype.updateState = function($happn, nodeArr) {
	const { dataService, eventService } = $happn.exchange;
	const { log } = $happn;

	return (async () => {
		try {
			let arr = nodeArr;
			if (!Array.isArray(nodeArr)) arr = [...nodeArr];

			let resultObj = { updates: [], inserts: [] };

			for (const unit of arr) {
				let upsertResult = await this.dataModel.upsertUnit(unit);

				if (!upsertResult || !upsertResult.action) {
					log.error("Return from dataModel is not in correct format");
				}

				switch (upsertResult.action) {
				case "INSERT":
					resultObj.inserts.push(upsertResult.value);
					break;
				case "UPDATE":
					resultObj.updates.push(upsertResult.value);
					break;
				case "NONE":
					break;
				case "ERROR":
					throw new Error(`Packet contains invalid data-${upsertResult.error}`);
				default:
					log.error("Unknown Update Action");
				}
			}

			if (resultObj.inserts.length > 0) {
				log.info(
					`DATA INSERTS: ${resultObj.inserts.length} new unit${
						resultObj.inserts.length === 1 ? "" : "s"
					}`
				);

				await eventService.handleEvent({
					type: dataServiceEvents.UNITS_INSERTED,
					serial: arr[0].data.serial,
					createdAt: arr[0].data.createdAt,
					typeId: arr[0].data.typeId,
					payload: resultObj.inserts
				});

				await dataService.persistUnits(resultObj.inserts);
			}

			if (resultObj.updates.length > 0) {
				log.info(
					`DATA UPDATE: ${resultObj.updates.length} existing unit${
						resultObj.updates.length === 1 ? "" : "s"
					}`
				);

				await eventService.handleEvent({
					type: dataServiceEvents.UNITS_UPDATED,
					serial: arr[0].data.serial,
					createdAt: resultObj.updates[0].data.modifiedAt,
					typeId: arr[0].data.typeId,
					payload: resultObj.updates
				});

				await dataService.persistUnits(resultObj.updates);
			}

			return resultObj;
		} catch (error) {
			throw new Error(`DataService UpdateState Error: ${error.message}`);
		}
	})();
};

/**
 * &lt;ul>
 * &lt;li>Preprocess the nodeArray to see if any action is required before updating&lt;/li>
 * &lt;li>.....&lt;/li>&lt;/ul>&lt;br>
 * @param {$happn} $happn Dependancy Injection of the Happner Framework
 * @param {object[]} nodeArr The incoming node array
 * @returns {Promise&lt;action>} Action
 
 * @mermaid sequenceDiagram
 * 			updateState->>dataModel: upsertUnit
 * 			dataModel->>updateState: return action
 * 			Note left of updateState: INSERT or UPDATE
 * 			updateState->>__updateExistingNodes: update
 * 			updateState->>__insertNewNodes: insert
 */
DataService.prototype.preProcess = function($happn, nodeArr) {
	const { log } = $happn;

	return (async () => {
		try {
			let result = [...nodeArr];
			const parentType = nodeArr[0].data.typeId;

			if (parentType === 3) {
				//clear EDDs when typeId is 4, and UID is 255.255.255.255
				if (nodeArr[0].dataType === "list" &amp;&amp; nodeArr.length === 2) {
					if (nodeArr[1].data.typeId === 4 &amp;&amp; nodeArr[1].data.serial === 4294967295) {
						log.info(`EDD_SIG for ${nodeArr[0].data.serial} received`);
						return { type: "EDD_CLEARSIG" };
					}
				}

				if (nodeArr[0].dataType === "data") {
					//edge case where strange edd comes in after eddsig in an 05 command
					if (
						result.length === 2 &amp;&amp;
						result[1].data.delay === 255 &amp;&amp;
						result[1].data.windowId === 255
					) {
						result = result.slice(0, 1);
					}
					return { type: "FILTERED", value: result };
				}
			}
			return { type: "DEFAULT" };
		} catch (err) {
			log.error("Proprocessing error", err);
		}
	})();
};

/**
 * &lt;ul>
 * &lt;li>Post Process Actions to update certain states&lt;/li>
 * &lt;li>.....&lt;/li>&lt;/ul>&lt;br>
 * @param {$happn} $happn Dependancy Injection of the Happner Framework
 * @param {object[]} updatesArr The incoming node array
 * @returns {Promise&lt;action>} Action
 */
DataService.prototype.postProcess = function($happn, parent, updatesArr) {
	const { dataService, blastService } = $happn.exchange;
	const { log } = $happn;

	return (async () => {
		try {
			const { keySwitchStatus, fireButton, typeId, modifiedAt, serial } = parent.data;
			const { diff } = updatesArr[0];

			switch (typeId) {
			case 0:
				{
					if (keySwitchStatus === 1 &amp;&amp; fireButton === 1 &amp;&amp; diff &amp;&amp; diff.fireButton === 1) {
						const snapShot = await this.dataModel.snapShot();

						let blastCreated = await blastService.createNewBlast(modifiedAt, snapShot);

						if (blastCreated) {
							let boosters = await this.dataModel.updateBoosterConnections(modifiedAt);

							if (boosters.length > 0) {
								for (let booster of boosters) {
									const result = await this.dataModel.upsertUnit(booster, true);
									const boosterArr = [result];
									await dataService.persistUnits(boosterArr);
								}
							}
						}
					}
				}
				break;
			case 3:
				{
					if (keySwitchStatus === 0 &amp;&amp; diff &amp;&amp; diff.keySwitchStatus === 0) {
						log.info(`Turning off Detonators for unit ${serial}`);
						const unit = await this.dataModel.getUnit(parent);

						const childKeys = Object.keys(unit.children);

						const resent = [];
						childKeys.forEach(child => {
							let det = clone(unit.children[child]);
							det.data.created = modifiedAt;
							det.data.detonatorStatus = 0;
							resent.push(det);
						});

						await dataService.updateState(resent);
					}
				}

				break;
			default: {
				return null;
			}
			}
		} catch (err) {
			log.error("Postprocessing err", err);
		}
	})();
};

/**
 * @summary Handle the node update from the CONTEXT.NEWNODES
 * @param {$happn} $happn
 * @param {units[]} updates - data context which stores context.newnodes
 */
DataService.prototype.persistUnits = function($happn, updates) {
	const { nodeRepository } = $happn.exchange;
	const { log } = $happn;

	return (async () => {
		try {
			for (let update of updates) {
				if (update &amp;&amp; update.hasOwnProperty("data")) {
					await nodeRepository.insertNodeData({ ...update.data });
				}
			}
		} catch (err) {
			log.error(`error updating`, err);
		}
	})();
};

/**
 * @summary Get the control unit
 * @param {$happn} $happn
 */
DataService.prototype.getControlUnit = function($happn) {
	const { log } = $happn;

	return (async () => {
		try {
			const controlUnit = this.dataModel.controlUnit;
			if (!controlUnit) return null;

			const cu = clone(controlUnit);

			delete cu.event;
			return cu;
		} catch (err) {
			log.error("Error getting control unit", err);
		}
	})();
};

/**
 * @summary Get the booster units
 * @param {$happn} $happn
 * @param {boolean} withChildren Get the units with their children
 */
DataService.prototype.getUnits = function($happn, withChildren) {
	const { log } = $happn;

	return (async () => {
		try {
			let result = clone(this.dataModel.units);
			let unitKeys = Object.keys(result);

			for (let i = 0; i &lt; unitKeys.length; i++) {
				delete result[unitKeys[i]].event;
				delete result[unitKeys[i]].meta;
				if (!withChildren) {
					delete result[unitKeys[i]].children;
				}
			}

			return result;
		} catch (err) {
			log.error("Error getting units", err);
		}
	})();
};

DataService.prototype.getSnapShot = function($happn) {
	const { log } = $happn;

	return (async () => {
		try {
			const snapShot = await this.dataModel.snapShot();
			return snapShot;
		} catch (err) {
			log.error("Snapshot error", err);
		}
	})();
};

/**
 * @category Services
 * @event DataService
 * @type {object}
 * @prop {object} Value to deine
 * @todo Document this object correctly
 */

/**
 * @category Services
 * @event EDDSIG
 * @summary Fires the Clear signal for a booster
 * @type {object}
 * @prop {string} parent.data.path the path of the unit the EDDSIG is from
 * @memberof DataService#
 */

/**
 * @category Services
 * @typedef {object} action
 * @prop {string} action.type Type of action
 * @prop {object} action.value Value of action
 * @example { type: "FILTERED", value: result }
 * @memberof DataService#
 *
 */

module.exports = DataService;
</code></pre>
        </article>
    </section>




                </div>
            </div>
        </div>
    </div>

<footer class="footer">
    <div class="content has-text-centered">
        <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Tue Nov 05 2019 12:38:15 GMT+0200 (South Africa Standard Time)</p>
        <p class="sidebar-created-by">
            <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
            <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
        </p>
    </div>
</footer>

<script src="scripts/app.min.js"></script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
